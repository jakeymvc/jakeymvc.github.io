---
title:  "간단한 SSO #1 - 접근법"
date:   2015-01-24 12:30:00
categories: mvc
tags: hmac 보안
author: Jake Ryu
permalink: /sso-approach/
---

앞으로 네 편의 글을 통해 웹 페이지간에 데이터를 교환하면서 그 내용을 노출하지 않고 위변조도 방지할 수 있는 기법을 알아볼 것이다. 암호화(`Cryptography`)와 `HMAC`(Hash-based Message Authentication)이 그 핵심 기술인데, 이 두가지 기법을 응용하면 데이터를 안전하게 전달할 수 있다. 대표적인 예로, 웹 사이트간에 추가적인 로그인 과정을 피할 수 있는 `Single Sign-On` 을 구현해 보고자 한다. 

이 글은 세편 중 첫번째로 어떻게 접근할지 개념적으로 알아본다. 


# 쿼리스트링

쿼리스트링은 웹 페이지간에 데이터를 전달할 수 있는 가장 간단한 방법이지만 사용자에게 데이터를 그대로 노출한다는 것이 언제나 꺼림직하다. 게다가 그 형식 또한, key-value 쌍으로 묶여 있어 어렵지 않게 그 용도를 파악할 수 있다. 브라우저의 주소창을 주의깊게 보고 쿼리스트링의 구조를 이해한 사용자라면 호기심이 발동할지도 모른다

# Data Privacy 와 Data Integrity

쿼리스트링 (좀더 일반적인 표현으로 URL)을 통해서 데이터를 전달하는 방식은 편리하지만 두 가지 위험이 따른다. 값이 사용자에게 노출되어 `Data Privacy`를 지킬 수 없고 URL은 쉽게 수정이 가능하기 때문에 원래 데이터인지 (`Data Integrity`) 확인하기가 어렵다. 

직관적인 비교를 위해 아래와 같은 두 가지 URL을 예로 들어보자. 

1. http://shopping.com/MyAccount.aspx?UserId=120
2. http://shopping.com/MyAccount.aspx?UserId=lQSol9eVl9iMJ1Xgu0-R3A2

첫 번째 URL을 살펴보면, 계정 정보를 확인하는 페이지에 `User ID`가 쿼리스트링으로 전달되고 있는 것을 알 수 있다. 만약, 이 페이지가 추가적인 본인 확인 절차없이 접근을 허용하다면 `UserID`의 값을 변경함으로써 다른 사용자의 정보도 쉽게 볼 수 있을 것이다. 그러나, 두 번째 URL을 보면 UserID의 값이 암호화 되어 있어 그 내용도 파악할 수 없고 변경하여 다른 사용자로 가장하려고 해도 딱히 방법이 떠오르지 않는다. 

# ASP.NET MVC의 URL 세그먼트 변수 

예로 본 URL과 같이 단순히 ID값을 넘겨 상세내용을 조회하는 경우, MVC에서는 아래 코드와 같이 키 값을 세그먼트 변수로 정의한다. 

{% highlight C# %}
routes.MapRoute(
            name: "Default",
            url: "{controller}/{action}/{id}",
            defaults: new { controller = "Home", action = "Index", id = UrlParameter.Optional }
        );
{% endhighlight %}

쿼리스트링도 물론 사용할 수 있지만 세그먼트 변수로 정의할 때 얻는 편리함이 있다. 라우팅 설정에서 세그먼트 변수로 정의되면 RouteValue 컬렉션에 추가되므로 편리하게 값에 접근할 수 있다. 세그먼트 변수로 정의되지 않은 데이터는 자동으로  쿼리스트링의 형태로 전달된다. 예제에서는 `UserID`를 세그먼트 변수로 정의하여 라우팅 시스템에 포함시키고 있다.

# 암호화를 다룰 수 있는 최적의 포인트 찾기

ID의 노출을 방지하고 위조를 어렵게하기 위해, 세그먼트 변수를 암호화 할 수 있는 방법을 생각해보자. 관리자용 사용자  목록이 있고 이 곳에서 하나의 사용자를 선택해 상세정보를 확인하는, 목록과 상세정보의 두 페이지가 있다고 가정해 보자. 

사용자 목록에서는 각 사용자를 한 줄 아이템으로 출력하면서, 사용자 상세정보 페이지로 이동할 링크를 미리 준비하여 이름과 함께 링크를 걸어둔다. 이렇게 목록에서 상세정보 페이지에 대한 링크(나가는 URL 또는 `Outgoing URL`)를 준비할 때, ID와 같은 사용자 정보는 암호화 되어 있어야 노출을 막을 수 있다. 또한, 상세정보 페이지에서는 요청된 URL(들어오는 URL 또는 `Incoming URL`)을 보고 암호화된 사용자 정보(ID)를 읽을 수 (복호화할 수) 있어야 한다. 

이런 수고를 ID가 포함된 URL을 사용할 때마다, 그리고 ID 값을 받는 모든 페이지마다 해야한다면... (흠). 

MVC 애플리케이션에서 URL하면 떠올려야 할 것이 라우팅 시스템이다. 라우트(Route)란 HTTP 요청을 식별하고 추가 작업을 가능하게 하는 단위라고 할 수 있다. 라우트를 새로 만든다는 것은, 식별하는 기준이 될 URL 패턴을 알려주는 것과 그 요청을 (라우트 핸들러를 지정함으로써) 처리할 방법을 지정하는 것이다. 특히, URL 패턴은 들어오는 요청을 식별할 뿐만 아니라, 나가는 URL을 동적으로 만들때도 사용되므로 일관성을 유지하면서 모든 URL을 통제할 수 있다. 

![ASP.NET MVC 요청 처리 파이프라인](/assets/mvc/mvc-request-pipeline.png)

<그림 1> ASP.NET MVC 요청 처리 파이프라인

위의 그림에서 주목할 부분은 Matching route entry 단계이다.

모든 라우트는 RouteTable에 저장되고 Routes라는 정적 속성을 통해 접근할 수 있다. 이 속성은 RouteCollection 형식이어서 쉽게 라우트를 추가할 수 있고, ASP.NET 라우팅 시스템은 이 컬렉션을 순환하면서 URL로 제공된 패턴과 매치되는 첫 번째 라우트를 찾는다. 컬렉션을 순환하면서 등록된 각 라우트의 멤버 메서드인 `GetRouteData` 를 호출해 보고, 그 결과로  `RouteData`를 반환하는 라우트를 매치라고 본다.

`RouteData`를 반환하고 있다는 점이 중요하다. 우리가 암호화-복호화할 대상은 세그먼트 변수로서 `RouteData`에 들어 있기 때문이다. 

라우팅 처리는 요청 파이프라인에서 이루어지므로 웹 페이지가 호출되기 전에 무언가 할 수 있는 기회를 제공한다. Route 데이터를 다루는 시점에서 자동으로 암호화-복호화할 수 있다면 기존 애플리케이션을 수정하지 않고도 Data Privacy를 구현할 수 있다.  

# 위변조 방지

쿼리스트링 값의 위변조를 방지하기 위해 `HMAC` (Hash-based Message Authentication) 기법에 대해 알아보자.

해싱은 원문(plain text)을 일정 길이의 바이트로 변환하는데 그 결과가 유일하여 긴 문장의 빠른 검색을 위한 키 값으로 많이 쓰인다. 그리고, 해시된 결과를 사용해서 거꾸로 원문을 복구할 수 없다는 것이 해시를 사용하는 고유한 가치라고 할 수 있다. 이러한 해시의 특성을 사용하여 데이터의 위변조 여부를 알아낼 수 있다. 

아래 그림을 통해, Sender가 전달한 UserID를 Receiver 입장에서 어떻게 신뢰할 수 있는지 알아보자. 

![HMAC을 적용한 쿼리스트링 보안](/assets/mvc/hmac.png)

<그림 2> HMAC을 적용한 쿼리스트링 보안

1. 사전에 Sender와 Receiver는 별도 채널로 해시에 사용할 키 `shared key`를 공유한다. 그리고, 양쪽에서 공히 사용할 해시 알고리즘을 정한다.

2. Sender는 공유키를 사용해서 User ID를 해시한다.

3. Sender는 원본 User ID와 그 해시결과(HMAC)를 쿼리스트링 값으로 Receiver에게 전달한다.

4. Receiver는 받은 User ID를 공유키를 사용하여 같은 알고리즘으로 해시한 결과(Receiver's HMAC)를 만든다.

5. Receiver가 만든 HMAC과 쿼리스트링으로 받은 HMAC이 같다면 User ID는 변경되지 않았다고 신뢰할 수 있다. 


# 정리

보안상 쿼리스트링 파라미터를 암호화해야 겠다는 요건과 라우팅 시스템을 사용자 정의할 수 있다는 아이디어에서 이 글을 작성하게 되었다. 전체적인 개념을 다시 한번 정리하고 SSO 구현에 어떻게 응용할 것인지 살펴보자. 

**Data Privacy**

- 사용자 정의 라우팅은 나가는 URL에 대해 UserID를 암호화 한다.
- 사용자 정의 라우팅은 들어오는 요청에 대해 UserID를 복호화 한다.

**Data Integrity**

- HMAC 기법으로 쿼리스트링 값의 위변조 여부를 알 수 있다.

<br />

A라는 사이트에 로그인한 사용자가 추가 로그인 없이 B 사이트에 접속하는 것이 여기서 구현하는 SSO의 목표이다. 이 방식의 최대 단점은 사용자 정보가 양쪽 웹 사이트에 동일하게 존재해야 한다는 것이다 (다르더라도 사용자를 구분하기 위해 최소한 ID 정도는 같아야 한다). 이상적인 SSO을 고려하고 있다면 Security Token Service와 Claims-based Identity 관리에 대해 알아볼 것을 추천한다.

아주 간단한 SSO 이지만 최소한의 구현 요건으로써, 1) 전송되는 데이터는 사용자가 알아 볼 수 없도록 암호화되어야 하고, 2) 사이트 이동 과정에서 사용자 정보의 위변조가 불가능한 신뢰할 수 있는 방법이어야 한다. 이어지는 세 편의 글을 통해 실제 업무에도 응용할 수 있는 예제를 구현해 보자.

*연재 글*

- **간단한 SSO #1 - 접근법**
- [간단한 SSO #2 - 라우팅](/sso-routing/)
- [간단한 SSO #3 - 암호화](/sso-encryption/)
- [간단한 SSO #4 - 위조방지](/sso-hmac/)