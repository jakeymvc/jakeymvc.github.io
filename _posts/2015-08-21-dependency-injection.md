---
title:  "ASP.NET 5 종속성 주입 (Dependency Injection)"
date:   2015-08-21 10:00:00
categories: aspnet5
author: Jake Ryu
permalink: /aspnet5-di/
---

IT 업계에서 변하지 않는 유일한 것이 있다면 변화 그 자체라는 말이 있다. 그럼에도 불구하고 변화에 유연하게 대처할 수 있는 애플리케이션을 작성하는 일은 쉬운 일이 아니다. 객체지향적으로 클래스가 잘 설계되었다 해도 한 클래스에서 다른 클래스의 인스턴스를 생성하는 방식은 클래스간의 의존성을 만들기 때문에 부분적인 변경이라도 전체적인 영향을 항상 검토해야 한다. 따라서, 클래스 간의 결합은 느슨해야 하고 이렇게 결합력이 약한 애플리케이션은 변경에 유연하게 대처할 수 있다.

‘Program to interface, not implementation’ 라는 중요한 설계 원칙이 있다. 여기서 인터페이스는 일종의 계약이다. 계약은 지켜져야 하고 합의 후 변경할 수 없기 때문에 인터페이스를 사용하는 코드는 구현체인 클래스를 사용하는 코드보다 유지보수에서 유리하다.

인터페이스를 사용하는 코드는 인터페이스 변수에 대입하는 클래스를 바꾸는 것만으로 애플리케이션의 로직을 변경할 수 있다. 그리고, 이런 대입 과정은 로직에서 분리되어야 한다.

아래의 예제 코드는 Ninject라는 종속성 주입 컨테이너를 사용하여 주문과 함께 로깅이 필요한 시나리오의 로깅 모듈이 어떻게 주문 모듈과 결합되어 있는지 보여준다. 종속성 주입 컨테이너에 대해서는 나중에 설명한다.

<리스트 1> 주문시 로깅처리하는 예제

{% highlight c# %}
// 종속성 주입 컨테이너 준비
IKernel ninjectKernel = new StandardKernel();

// ILogger 인터페이스에 XmlLogger를 사용하도록 지정
ninjectKernel.Bind<ILogger>().To<XmlLogger>();

// 종속성 주입 컨테이너가 바인딩 설정에 기반해서 클래스를 생성하고
// ILogger 인터페이스 형식 변수에 클래스를 할당한다.
ILogger logger = ninjectKernel.Get<ILogger>();

// 주문 클래스를 생성하면서 종속성을 주입한다.
Order o = new Order(logger);

// 주문 후 처리 결과는 주입된 logger에 의해 기록된다.
o.Place();
{% endhighlight %}

코드에 포함되지는 않았지만 Save 라는 메서드를 정의하는 간단한 ILogger 인터페이스가 있고 이를 구현하고 있는 XmlLogger가 사용되었다. 만약, 로깅을 위해 데이터베이스가 필요하다고 판단되면 ILogger를 구현하는 DatabaseLogger 클래스를 만들어서 XmlLogger 대신 바인딩 하면 그만이다. 

이런 변경은 로깅을 사용하는 상위 모듈, 즉 Order 클래스를 변경하지 않고 가능해야 좋은 설계라고 할 수 있다. 

상위 모듈은 하위 모듈을 사용하면서 어쩔 수 없이 의존성을 갖게 되지만 하위 모듈의 변경이 상위 모듈의 변경으로 이어지는 것은 유지보수를 어렵게 만든다. 이 것이 모듈들을 느슨하게 결합해야 하는 이유이다. 

종속성은 비즈니스 로직(여기서는 주문)과 상관없는 실행환경에서 관리되어야 한다. 만약, Order 클래스에서 XmlLogger를 직접 사용한다면 강한 결합이 되어 로깅 모듈 수정시 Order 클래스에 대한 수정을 피할 수 없다. 다시 말해, 상위 모듈이 영향을 받는 셈이다. 

Order 클래스의 생성자 또는 세터를 통해 로깅 모듈을 주입하면 외부에서 로깅 모듈을 제어하는 셈이 된다. 이 때 주입하는 것은 인터페이스인데, 이 인터페이스에 어떤 클래스의 인스턴스를 대입해 주는가 하는 것이 종속성 주입 컨테이너의 역할이고 리스트 1의 초반부 설정에 표현되어 있다.

이런 컨테이너로는 예제에서 사용한 Ninject 또는 Autofac 등이 많이 사용되며 마이크로소프트에서도 Unity Container를 NuGet 패키지로 제공해 왔다. 

별도 패키지로 설치하고 구성해야 했던 종속성 주입 컨테이너가 MVC 6에 들어서는 프레임워크 수준에서 제공된다. 그렇다고 이 빌트인 컨테이너가 강제화된 것은 아니다. MVC 6는 개발자의 편의를 위해 프레임워크 차원에서 최소 기능의 종속성 주입 컨테이너를 제공할 뿐이다. 보다 강력한 기능이 필요하거나 복잡한 시나리오에서는 자신이 선호하는 컨테이너를 사용하면 된다. 빌트인 컨테이너의 제약점은 후반부에 따로 정리했다.

리스트 2는 MVC 6에서 종속성을 주입하는 방법을 보여주고 있다.

<리스트 2> MVC 6 프레임워크를 사용한 종속성 주입

{% highlight c# %}
public class Startup
{
    public void Configure(IBuilder app)
    {
        ...
        app.UseServices(services =>
        {
            ...
            // 종속성 설정
            services.AddTransient<ILogger, XmlLogger>();
            ...
        });
        ...
    }
}
{% endhighlight %}

`UseServices` 메서드는 그 이름에서 느껴지듯 서비스를 사용한다는 의미일텐데, 서비스를 추가하는 모양새가 종속성 주입의 형태를 갖는다. 서비스와 종속성은 어떤 관계일까.

서비스는 애플리케이션에서 공통으로 사용하도록 의도한 컴포넌트이다. 이런 서비스들은 종속성 주입을 통해서 사용 가능한데 아마도 이 때문에 종속성 주입 컨테이너가 빌트인으로 제공되는 것 같다. 이 컨테이너가 제공하는 서비스의 수명 관리방식은 세 가지다.

* Singleton
* Scoped  (현재 스콥에 존재하는 서비스가 없을 때만 서비스를 생성) 
* Transient (컨테이너의 의해 서비스가 요청될 때마다 서비스 생성)

웹 애플리케이션에서 컨테이너 스콥은 요청마다 생성되므로 Scoped 서비스는 per request 서비스라고 생각할 수 있다.

현재 버전에서 빌트인 컨테이너는 다음과 같은 제약이 있다.

* 생성자를 통한 종속성 주입만 지원
* 오직 하나의 PUBLIC 생성자를 갖는 클래스만 이해
* 스레드 스콥, 오토 디스커버리 같은 고급 기능 지원 못함

반면에 이전에 불가능했던 것이 가능한 것도 있다. 이 것은 종속성 주입 컨테이너 구현을 추상화한 `IServiceProvider` 인터페이스 덕분이다. 프레임워크 컴포넌트들(MVC, Routing, SignalR, Entity Framework 등)은 `IServiceProvider` 를 구현하는 종속성 주입 컨테이너를 사용하기 때문에 컴포넌트간을 넘나 드는, 다시 말해 스택을 가로지르는 종속성을 갖을 수 있다. 서비스를 등록하기 위해 하나의 컨테이너를 사용하기 때문에 로깅 모듈을 스택의 다른 레이어마다 반복적으로 정의하지 않고 하나의 엔트리만으로 해결이 가능하고, MVC 컨트롤러 액션 메서드에 SignalR 브로드캐스터를 주입하는 것도 가능하다.

현재도 한창 개발중인 프레임워크라 예제를 들어 설명하지 못하는 것이 아쉽지만 다음을 기약해 본다.

이 빌트인 컨테이너는 고급 설정까지 필요없는 간단한 시나리오에서 하나의 컨테이너로 여러 가지 서비스를 관리한다는 목적으로 사용하는 것이 좋을 것 같다. 


[참고 자료]

* [Dependency Injection in ASP.NET vNext](http://blogs.msdn.com/b/webdev/archive/2014/06/17/dependency-injection-in-asp-net-vnext.aspx)

* [Introduction to ASP.NET 5]
(http://docs.asp.net/en/latest/conceptual-overview/aspnet.html?highlight=dependency#services)



